### 总结

+ 深度优先搜索：递归

  + 先序遍历：

    ```python
    # 需要先记录结果，在进行递归（自顶向下）
    class Solution(object):
        def preorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    		# TODO: do work
            preorderTraversal(root.left)
            preorderTraversal(root.right)
    ```

  + 中序遍历：

    ```python
    class Solution(object):
        def inorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            inorderTraversal(root.left)
       		# TODO: do work
            inorderTraversal(root.right)
    ```

  + 后序遍历：

    ```python
    # 需要先进行递归，在进行记录结果（自底向下）
    class Solution(object):
        def postorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            postorderTraversal(root.left)
            postorderTraversal(root.right)
       		# TODO: do work
    ```

+ 广度优先搜索：用到队列（先进先出），处理每一层，将每一层节点入队。

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
  
                  if right_node:
                      qlist.append(right_node)
                  
                  #TODO：do work
  
  ```

+ 将树转换成一个数组的形式，那么会有这个公式：假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2

+ 完全二叉树的定义：**它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧。**

+ 对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标

+ **满二叉树的层数为h，则总节点数为：2^h - 1.**

### 类

```python
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    @classmethod
    def build(cls, val_list):
        node_list = list()
        n = len(val_list)
        for index in range(n):
            val = val_list[index]
            node = TreeNode(val)
            node_list.append(node)
        for index in range(n):
            left_index = index * 2 + 1
            right_index = index * 2 + 2
            node = node_list[index]
            if left_index < n:
                left_node = node_list[left_index]
                node.left = left_node
            if right_index < n:
                right_node = node_list[right_index]
                node.right = right_node
        return node_list[0]

    @staticmethod
    def maxDepth(root):
        if not root:
            return 0

        left_cnt = TreeNode.maxDepth(root.left) + 1
        right_cnt = TreeNode.maxDepth(root.right) + 1
        return max(left_cnt, right_cnt)

    @staticmethod
    def printf(root):
        # 空格的次数
        depth = TreeNode.maxDepth(root)
        queue_list = [root]
        while len(queue_list):
            print("\t" * depth),
            node_cnt = len(queue_list)  # 当前这一层node的个数
            for _ in range(node_cnt):
                node = queue_list[0]
                queue_list.pop(0)
                left_node = node.left
                right_node = node.right
                if left_node:
                    queue_list.append(left_node)
                if right_node:
                    queue_list.append(right_node)
                print(node.val),
                print("\t" * depth),
            depth -= 1
            print("\n"),
```



### 二叉树最大深度

+ 力扣104：[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

  ```
  给定一个二叉树，找出其最大深度。
  二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
  说明: 叶子节点是指没有子节点的节点。
  
  给定二叉树 [3,9,20,null,null,15,7]，
  返回它的最大深度 3 。
  ```

+ 题解：深度遍优先搜索

  ```python
  class Solution:
      def maxDepth(self, root):
          if root is None: 
              return 0 
  
  		left_height = self.maxDepth(root.left) + 1 
  		right_height = self.maxDepth(root.right) + 1 
  		return max(left_height, right_height) 
  ```

### 二叉树的最小深度

+ 力扣111：[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

  ```python
  给定一个二叉树，找出其最小深度。
  最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
  
  输入：root = [3,9,20,null,null,15,7]
  输出：2
  
  输入：root = [2,null,3,null,4,null,5,null,6]
  输出：5
  ```

+ 题解：该问题实际就是问根节点到叶子的最短路径

  + 用一个值用于保存结果
  + 计算到叶子节点的层数（左右节点为None）
  + 保存最小值

  ```python
  class Solution(object):
      def minDepth(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def f(root, cnt, min_cnt):
              if not root.left and not root.right:
                  min_cnt = min(cnt, min_cnt)
                  return min_cnt
              cnt += 1
              if root.left:
                  min_cnt = f(root.left, cnt, min_cnt)
              if root.right:
                  min_cnt = f(root.right, cnt, min_cnt)
              return min_cnt
  
          if not root :
              return 0
          cnt = 1
          min_cnt = sys.maxint
          min_cnt = f(root, cnt, min_cnt)
          return min_cnt
  ```

### 对称二叉树

+ 力扣101：[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

  ```
  给定一个二叉树，检查它是否是镜像对称的。
  
  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
  ```

+ 题解：

  + 每个树的右子树都与另一个树的左子树镜像对称
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSymmetric(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.right) and check(pnode.right, qnode.left)
  
  
          if not root:
              return False
  
          return check(root.left, root.right)
  ```

### 相同树

+ 力扣100：[相同的树](https://leetcode-cn.com/problems/same-tree/)

  ```
  给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
  如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

  输入：p = [1,2,3], q = [1,2,3]
  输出：true
  
  输入：p = [1,2], q = [1,null,2]
  输出：false
  ```
  
+ 题解：这道题跟上面到对称二叉树查不到

  + 每个树的右（左）子树都与另一个树的右（左）子树相同
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          return check(p,q)
  ```

### 另一个树的子树

+ 力扣572：[另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

  ```
  给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
  
  输入：s = [3,4,5,1,2] t = [4,1,2]
  输出：true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
  
  输入：s = [3,4,5,1,2,null,null,null,null,0] t = [4,1,2]
  输出：false
  
  ```

+ 题解：这道题跟上面相同树一样

  + 结合上面的相同树，将s的每个节点当成root，进行比较

  ```python
  class Solution(object):
      def isSubtree(self, s, t):
          """
          :type s: TreeNode
          :type t: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          qlist = [s]
          while len(qlist):
              n = len(qlist)
              for index in range(n):
                  node = qlist[0]
                  qlist.pop(0)
                  if check(node, t):
                      return True
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
          return False
  		"""
  		深度搜索
  		# 遍历root节点，左节点，右节点
          if not s:
              return False
          return check(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
  		"""
  ```

### 同构树

+ 腾讯题：[同构树-TX](https://blog.csdn.net/weixin_43088751/article/details/104079228)

  ```
  简单来说，对于二叉树，如果一个树的孩子节点通过左右变换可以变成另外一个树，那么这两个树是同构的。
  ```

+ 题解：

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              # 同构树下面两种情况其中1中
              # 1.左子树等于左子树，右子树等于右子树 
              # 2.左子树等于右子树，左子树等于右子树
              return (check(pnode.left, qnode.left) and check(pnode.right, qnode.right)) or (check(pnode.left, qnode.right) and check(pnode.right, qnode.left))
  
          return check(p,q)
  ```

### 翻转二叉树

+ 力扣226：[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

  ```
  翻转一棵二叉树。
  
  输入：[4,2,7,1,3,6,9]
  输出：[4,7,2,9,6,3,1]
  ```

+ 题解：利用前序遍历（TLR）

  + 先遍历到root
  + 然后交换root的left和right（交换后下面的结构就已经变换了，可以画图）

  ```python
  class Solution(object):
      def invertTree(self, root):
          """
          :type root: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return
  
          node = root.left
          root.left = root.right
          root.right = node
          self.invertTree(root.left)
          self.invertTree(root.right)
          return root
  ```

### 左叶子之和

+ 力扣404[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

  ```
  计算给定二叉树的所有左叶子之和。
  
  输入：[3,9,20,None,None,15,7]
  输出：24
  ```

+ 题解：

  + 判断一个节点的左节点是不是叶子节点，如果是则累加该节点的值

  ```python
  class Solution(object):
      def sumOfLeftLeaves(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def isLeafNode(root):
              if not root.left and not root.right:
                  return True
              return False
  
          if not root:
              return 0
  
          ans = 0
          if root.left:
              if isLeafNode(root.left):
                  ans = root.left.val
              ans += self.sumOfLeftLeaves(root.left)
          # 上面已经加过一次了，这里就只需要计算right的情况
          if root.right:
              ans += self.sumOfLeftLeaves(root.right)
  
          return ans
  ```

### 二叉树的完全性检验

+ 力扣958：[二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

  ```
  给定一个二叉树，确定它是否是一个完全二叉树。
  百度百科中对完全二叉树的定义如下：
  若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）
  
  输入：[1,2,3,4,5,6]
  输出：true
  解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
  
  输入：[1,2,3,4,5,null,7]
  输出：false
  解释：值为 7 的结点没有尽可能靠向左侧。
  ```

+ 题解：

  + 将树转换成一个数组的形式，那么会有这个公式：**假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2**
  + **对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标**

  ```python
  class Solution(object):
      def isCompleteTree(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          cnt = 0  # 计算总个数
          index_map = {root: 0} # 保存节点对应的下标
          max_index = 0 # 记录最大下标
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  cnt += 1
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                      left_index = index * 2 + 1
                      index_map[left_node] = left_index
                      max_index = left_index
  
                  if right_node:
                      qlist.append(right_node)
                      right_index = index * 2 + 2
                      index_map[right_node] = right_index
                      max_index = right_index
  
  		# 这里是用总个数，所以要总个数-1，因为下标从0开始
          return max_index == cnt-1
  ```


### 完全二叉树的节点个数

+ 力扣222：[完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

  ```
  给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
  
  完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
  
  输入：root = [1,2,3,4,5,6]
  输出：6
  
  输入：root = []
  输出：0
  
  输入：root = [1]
  输出：1
  ```

+ 题解：[题解](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/c-san-chong-fang-fa-jie-jue-wan-quan-er-cha-shu-de/)

  + **这是一棵完全二叉树**：除最后一层外，其余层全部铺满；且最后一层向左停靠
  + 如果根节点的左子树深度等于右子树深度，则说明**左子树为满二叉树**（可以画图）
  + 如果根节点的左子树深度大于右子树深度，则说明**右子树为满二叉树**（可以画图）
  + 满二叉树的层数为h，则总节点数为：2^h - 1.（1 << depth - 1）
  + 那么可以得到一个公式（获得当前root总节点个数）：root = （1 << left_depth | right_depth - 1）+ fun(root.right | root.left)  + 1
    + 左子树（右子树）满二叉树的总节点数 + 递归右子树（左子树）总节点数 + 1（root节点）

  ```python
  class Solution(object):
      def countNodes(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def getDepth(root):
              if not root:
                  return 0
  
              cnt = 0
              while root:
                  root = root.left
                  cnt += 1
              return cnt
  
          if not root:
              return 0
          left_depth = getDepth(root.left)
          right_depth = getDepth(root.right)
          # 根据完全二叉树的性质：
          # 如果左子树高度等于右子树高度。则左子树为满二叉树。
          # 如果左子树高度不等于右子树高度。则右子树为满二叉树。
          # 满二叉树的总结点数：2^h - 1 （深度从1开始计算）
          if left_depth == right_depth:
              # 该root节点的个数等于：左子树满二叉树的总个数 + 递归右子树（非满二叉树） + 1（root节点）
              return self.countNodes(root.right) + (1 << left_depth)  # (1 << left_depth -1) + 1
          else:
              # 右子树是满二叉树
              return self.countNodes(root.left) + (1 << right_depth)  # (1 << right_depth -1) + 1
  ```

### 二叉树的直径

+ 力扣543：[二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

  ```
  给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
  注意：两结点之间的路径长度是以它们之间边的数目表示。
  
  输入：root = [1,2,3,4,5]
  输出：3  它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
  ```

+ 题解：[题解](https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/)

  + 对于该节点的左儿子向下遍历经过最多的节点数 LL （即以左儿子为根的子树的深度） 
  + 其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度）
  + 那么以该节点为起点的路径经过节点数的最大值即为 L+R+1
  + 记节点node 为起点的路径经过节点数的最大值为node_max，那么二叉树的直径就是所有节点node_max-1

  ```python
  class Solution(object):
      def diameterOfBinaryTree(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def maxDepth(root):
              if not root:
                  return 0
              # 左子树为根的深度
              left_depth = maxDepth(root.left)
              # 右子树为根的深度
              right_depth = maxDepth(root.right)
              # 该节点为根，其左右子树最深高度和，跟max_depth比较
              self.ans = max(self.ans, left_depth + right_depth + 1)
              # 返回该节点为根的最深高度
              return max(left_depth, right_depth) + 1
          if not root:
              return 0
          self.ans = 0
          maxDepth(root)
          return self.ans - 1 # 注意：两结点之间的路径长度是以它们之间边的数目表示。所以要深度-1
  ```

### 二叉树的坡度

+ 力扣563：[二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

  ```
  给定一个二叉树，计算 整个树 的坡度 。
  一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
  整个树 的坡度就是其所有节点的坡度之和。
  
  输入：root = [1,2,3]
  输出：1
  解释：
  节点 2 的坡度：|0-0| = 0（没有子节点）
  节点 3 的坡度：|0-0| = 0（没有子节点）
  节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）
  坡度总和：0 + 0 + 1 = 1
  
  输入：root = [4,2,9,3,5,null,7]
  输出：15
  解释：
  节点 3 的坡度：|0-0| = 0（没有子节点）
  节点 5 的坡度：|0-0| = 0（没有子节点）
  节点 7 的坡度：|0-0| = 0（没有子节点）
  节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）
  节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）
  ```

+ 题解：

  + 用于一个全局变量保存每个坡度的值
  + 递归函数的返回值：左子树的和+右子树的和+该节点的值（用于该节点的父节点来做差值）

  ```python
  class Solution(object):
      def findTilt(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.ans = 0
          def calc(root):
              if not root:
                  return 0
              left_val = calc(root.left)
              right_val = calc(root.right)
              self.ans += abs(left_val - right_val)
              return left_val + right_val + root.val
          
          if not root:
              return 0
          calc(root)
          return self.ans
  ```

  