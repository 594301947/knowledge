### 总结

+ 深度优先搜索：递归

  + 先序遍历：

    ```python
    class Solution(object):
        def preorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    		# TODO: do work
            preorderTraversal(root.left)
            preorderTraversal(root.right)
    ```

  + 中序遍历：

    ```python
    class Solution(object):
        def inorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            inorderTraversal(root.left)
       		# TODO: do work
            inorderTraversal(root.right)
    ```

  + 后序遍历：

    ```python
    class Solution(object):
        def postorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            postorderTraversal(root.left)
            postorderTraversal(root.right)
       		# TODO: do work
    ```

+ 广度优先搜索：用到队列（先进先出），处理每一层，将每一层节点入队。

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
  
                  if right_node:
                      qlist.append(right_node)
                  
                  #TODO：do work
  
  ```

+ 将树转换成一个数组的形式，那么会有这个公式：假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2

+ 对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标

### 类

```python
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    @classmethod
    def build(cls, val_list):
        node_list = list()
        n = len(val_list)
        for index in range(n):
            val = val_list[index]
            node = TreeNode(val)
            node_list.append(node)
        for index in range(n):
            left_index = index * 2 + 1
            right_index = index * 2 + 2
            node = node_list[index]
            if left_index < n:
                left_node = node_list[left_index]
                node.left = left_node
            if right_index < n:
                right_node = node_list[right_index]
                node.right = right_node
        return node_list[0]

    @staticmethod
    def maxDepth(root):
        if not root:
            return 0

        left_cnt = TreeNode.maxDepth(root.left) + 1
        right_cnt = TreeNode.maxDepth(root.right) + 1
        return max(left_cnt, right_cnt)

    @staticmethod
    def printf(root):
        # 空格的次数
        depth = TreeNode.maxDepth(root)
        queue_list = [root]
        while len(queue_list):
            print("\t" * depth),
            node_cnt = len(queue_list)  # 当前这一层node的个数
            for _ in range(node_cnt):
                node = queue_list[0]
                queue_list.pop(0)
                left_node = node.left
                right_node = node.right
                if left_node:
                    queue_list.append(left_node)
                if right_node:
                    queue_list.append(right_node)
                print(node.val),
                print("\t" * depth),
            depth -= 1
            print("\n"),
```



### 二叉树最大深度

+ 力扣104：[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

  ```
  给定一个二叉树，找出其最大深度。
  二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
  说明: 叶子节点是指没有子节点的节点。
  
  给定二叉树 [3,9,20,null,null,15,7]，
  返回它的最大深度 3 。
  ```

+ 题解：深度遍优先搜索

  ```python
  class Solution:
      def maxDepth(self, root):
          if root is None: 
              return 0 
  
  		left_height = self.maxDepth(root.left) + 1 
  		right_height = self.maxDepth(root.right) + 1 
  		return max(left_height, right_height) 
  ```

### 二叉树的最小深度

+ 力扣111：[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

  ```python
  给定一个二叉树，找出其最小深度。
  最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
  
  输入：root = [3,9,20,null,null,15,7]
  输出：2
  
  输入：root = [2,null,3,null,4,null,5,null,6]
  输出：5
  ```

+ 题解：该问题实际就是问根节点到叶子的最短路径

  + 用一个值用于保存结果
  + 计算到叶子节点的层数（左右节点为None）
  + 保存最小值

  ```python
  class Solution(object):
      def minDepth(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def f(root, cnt, min_cnt):
              if not root.left and not root.right:
                  min_cnt = min(cnt, min_cnt)
                  return min_cnt
              cnt += 1
              if root.left:
                  min_cnt = f(root.left, cnt, min_cnt)
              if root.right:
                  min_cnt = f(root.right, cnt, min_cnt)
              return min_cnt
  
          if not root :
              return 0
          cnt = 1
          min_cnt = sys.maxint
          min_cnt = f(root, cnt, min_cnt)
          return min_cnt
  ```

### 对称二叉树

+ 力扣101：[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

  ```
  给定一个二叉树，检查它是否是镜像对称的。
  
  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
  ```

+ 题解：

  + 每个树的右子树都与另一个树的左子树镜像对称
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSymmetric(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.right) and check(pnode.right, qnode.left)
  
  
          if not root:
              return False
  
          return check(root.left, root.right)
  ```

### 相同树

+ 力扣100：[相同的树](https://leetcode-cn.com/problems/same-tree/)

  ```
  给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
  如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

  输入：p = [1,2,3], q = [1,2,3]
  输出：true
  
  输入：p = [1,2], q = [1,null,2]
  输出：false
  ```
  
+ 题解：这道题跟上面到对称二叉树查不到

  + 每个树的右（左）子树都与另一个树的右（左）子树相同
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          return check(p,q)
  ```

### 另一个树的子树

+ 力扣572：[另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

  ```
  给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
  
  输入：s = [3,4,5,1,2] t = [4,1,2]
  输出：true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
  
  输入：s = [3,4,5,1,2,null,null,null,null,0] t = [4,1,2]
  输出：false
  
  ```

+ 题解：这道题跟上面相同树一样

  + 结合上面的相同树，将s的每个节点当成root，进行比较

  ```python
  class Solution(object):
      def isSubtree(self, s, t):
          """
          :type s: TreeNode
          :type t: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          qlist = [s]
          while len(qlist):
              n = len(qlist)
              for index in range(n):
                  node = qlist[0]
                  qlist.pop(0)
                  if check(node, t):
                      return True
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
          return False
  		"""
  		深度搜索
  		# 遍历root节点，左节点，右节点
          if not s:
              return False
          return check(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
  		"""
  ```

### 同构树

+ 腾讯题：[同构树-TX](https://blog.csdn.net/weixin_43088751/article/details/104079228)

  ```
  简单来说，对于二叉树，如果一个树的孩子节点通过左右变换可以变成另外一个树，那么这两个树是同构的。
  ```

+ 题解：

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              # 同构树下面两种情况其中1中
              # 1.左子树等于左子树，右子树等于右子树 
              # 2.左子树等于右子树，左子树等于右子树
              return (check(pnode.left, qnode.left) and check(pnode.right, qnode.right)) or (check(pnode.left, qnode.right) and check(pnode.right, qnode.left))
  
          return check(p,q)
  ```

### 翻转二叉树

+ 力扣226：[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

  ```
  翻转一棵二叉树。
  
  输入：[4,2,7,1,3,6,9]
  输出：[4,7,2,9,6,3,1]
  ```

+ 题解：利用前序遍历（TLR）

  + 先遍历到root
  + 然后交换root的left和right（交换后下面的结构就已经变换了，可以画图）

  ```python
  class Solution(object):
      def invertTree(self, root):
          """
          :type root: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return
  
          node = root.left
          root.left = root.right
          root.right = node
          self.invertTree(root.left)
          self.invertTree(root.right)
          return root
  ```

### 左叶子之和

+ 力扣404[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

  ```
  计算给定二叉树的所有左叶子之和。
  
  输入：[3,9,20,None,None,15,7]
  输出：24
  ```

+ 题解：

  + 判断一个节点的左节点是不是叶子节点，如果是则累加该节点的值

  ```python
  class Solution(object):
      def sumOfLeftLeaves(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def isLeafNode(root):
              if not root.left and not root.right:
                  return True
              return False
  
          if not root:
              return 0
  
          ans = 0
          if root.left:
              if isLeafNode(root.left):
                  ans = root.left.val
              ans += self.sumOfLeftLeaves(root.left)
          # 上面已经加过一次了，这里就只需要计算right的情况
          if root.right:
              ans += self.sumOfLeftLeaves(root.right)
  
          return ans
  ```

### 二叉树的完全性检验

+ 力扣958：[二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

  ```
  给定一个二叉树，确定它是否是一个完全二叉树。
  百度百科中对完全二叉树的定义如下：
  若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）
  
  输入：[1,2,3,4,5,6]
  输出：true
  解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
  
  输入：[1,2,3,4,5,null,7]
  输出：false
  解释：值为 7 的结点没有尽可能靠向左侧。
  ```

+ 题解：

  + 将树转换成一个数组的形式，那么会有这个公式：**假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2**
  + **对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标**

  ```python
  class Solution(object):
      def isCompleteTree(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          cnt = 0  # 计算总个数
          index_map = {root: 0} # 保存节点对应的下标
          max_index = 0 # 记录最大下标
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  cnt += 1
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                      left_index = index * 2 + 1
                      index_map[left_node] = left_index
                      max_index = left_index
  
                  if right_node:
                      qlist.append(right_node)
                      right_index = index * 2 + 2
                      index_map[right_node] = right_index
                      max_index = right_index
  
  		# 这里是用总个数，所以要总个数-1，因为下标从0开始
          return max_index == cnt-1
  ```

  