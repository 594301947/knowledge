### 总结

1. **链表的题目画图可以更好理解**
2. 一般创建一个伪头结点：

### 类

```python
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    @classmethod
    def build(cls, node_list):
        head = cls(-1, None)
        ret = head
        for val in node_list:
            node = cls(val, None)
            head.next = node
            head = node
        return ret.next

    @staticmethod
    def printf(head):
        head_tmp = head
        while head_tmp:
            print(head_tmp.val),
            if head_tmp.next:
                print("->"),
            else:
                print("\n"),
            head_tmp = head_tmp.next
```

### 反转链表

+ 力扣206：[反转链表](https://leetcode-cn.com/problems/reverse-linked-list)

  ```
  反转一个单链表。
  示例:
  输入: 1->2->3->4->5->NULL
  输出: 5->4->3->2->1->NULL
  ```

+ 题解：**画图理解**

  + prev_node：保存上一个节点
  + next_node：保存下一个节点
  + cur_node：当前工作节点
  + next_node = cur_node.next：保存当前工作节点的下一个节点
  + cur_node.next = prev_node：让当前工作节点指向前一个
  + prev_node = cur_node：当前节点出来完了，用prev_node保存当前节点
  + cur_node = next_node：处理下一个节点

  ```python
  class Solution(object):
      def reverseList(self, head):
          """
          :type head: ListNode
          :rtype: ListNode
          """
          if not head or not head.next:
              return head
  
          prev_node = None
          next_node = None
          cur_node = head
          while cur_node:
              next_node = cur_node.next
              cur_node.next = prev_node
              prev_node = cur_node
              cur_node = next_node
  
          return prev_node
  ```

###  反转链表 II

+ 力扣92：[ 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii) 

  ```
  反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
  
  说明:
  1 ≤ m ≤ n ≤ 链表长度。
  示例:
  输入: 1->2->3->4->5->NULL, m = 2, n = 4
  输出: 1->4->3->2->5->NULL
  ```

+ 题解：**画图理解**

  + 先计算要反转的个数
  + 找到反转的起始位置，保存开始反转的node和该node的前节点。
  + 反转链表
  + 拆分后的链表进行重新连接

  ```python
  class Solution(object):
      def reverseBetween(self, head, left, right):
          """
          :type head: ListNode
          :type left: int
          :type right: int
          :rtype: ListNode
          """
          if not head or not head.next:
              return head
  
          prev_node = None
          next_node = None
          cur_node = head
          cnt = right - left  # 计算要反转的个数
  
          # 找到起始位置
          while left > 1:
              prev_node = cur_node
              cur_node = cur_node.next
              left -= 1
  
          conn_node = prev_node  # 记录保存开始反转的前一个节点，该节点用于连接反转后的头部
          tail_node = cur_node  # 记录保存开始反转的节点，该节点会是反转后的尾部
  
          # 链表反转
          while cnt >= 0:
              next_node = cur_node.next
              cur_node.next = prev_node
              prev_node = cur_node
              cur_node = next_node
              cnt -= 1
  
          # 如果连接节点不为None，则表示是非第一个节点反转，需要连接节点连接反转后的头部
          if conn_node:
              conn_node.next = prev_node
          else: # 从第一个节点开始反转，这个时候的head则是反转后的尾部
              head = prev_node
          
          # 连接反转后的尾部
          tail_node.next = cur_node
  
          return head
  ```

  

