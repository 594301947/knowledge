### read和write

+ read/write 数据实际上，数据是存放在内核中的缓冲区中的，①读数据，实际上是用户将内核缓冲区中的数据读到应用层缓冲区；②写数据，实际上是用户将应用层缓冲区中的数据，写入到内核缓冲区。
+ 在网络通信中，调用 read 后，从内核缓冲区读数据，要分为 2 步：①要等待内核缓冲区中有数据。②有数据了才能去读走数据，将数据从内核缓冲区拷贝到应用层缓冲区。因此，当内核缓冲区中没有数据可以读时，就会阻塞！
+ 同理，调用write后，写入内核缓冲区，要分为2步：①要等待内核缓冲区中有剩余空间。②由剩余空间才能去写入数据，将数据从应用层缓冲区拷贝到内核冲区。因此，当内核缓冲区中没有数据可以写空间时，就会阻塞！

### 五种IO模型

+ 阻塞IO：当调用 read 函数阻塞读取数据时，如果此时内核缓冲区中没有数据，就阻塞等待，这就是阻塞 IO 模型。当内核缓冲区中有数据时，read 函数将读到数据，就会将数据拷贝到应用层缓冲区。
+ 非阻塞IO：非阻塞 read 数据时，当内核缓冲区中没有数据时，程序将不会一直阻塞在 read 函，read 函数会立即返回（EWOULDBLOCK）。此时程序员可以控制程序去做其他事情。在此期间，程序员要不断的轮询调用 read 查看是否有数据到来，直到有数据到来，read 才读取数据。（忙等待，CPU利用率低）
+ 信号驱动IO：此方式，需要应用程序注册回调函数，【主动】将数据从内核空间拷贝到应用空间，是一种【拉模式】
  +  首先，应用程序需要建立信号处理程序（当数据到来时，从内核中拷贝数据到应用层）
  +  然后，当内核中数据准备好的时候，会给应用程序发送一个信号，SIGIO
  +  最后，会触发注册的信号处理函数，将数据拷贝走
+ 异步IO/完成端口：可以看到，这种模式和“信号驱动 IO”最大的区别是：当内核中数据准备好后，是内核主动的将数据拷贝到应用空间（而不是由应用层自己注册的回调函数，将数据拷贝到应用层空间）。这是一种【推模式】。内核将数据拷贝到应用层空间后，将会通知你，你之后就可以处理接下来的逻辑了。
  + 当应用程序调用 aio_read 时，内核一方面去取数据报内容返回另一方面将程序控制权还给应用程序
  + 应用程序继续执行其他的任务，是一种非阻塞的状态
  + 当内核中的数据报就绪时，由内核主动地将数据报拷贝到应用程序中，返回 aio_read 中定义好的函数处理程序
+ 异步 IO 与同步 IO 的核心区别：异步 IO 无需自己负责读写，会自动将数据从内核空间拷贝到用户空间
+ IO多路复用：IO 多路复用有一个文件描述符集合，对这个集合中的每个元素进行循环监听，处理就绪的文件描述符。IO 多路复用属于阻塞 IO，但是可以对多个 fd 进行阻塞监听
