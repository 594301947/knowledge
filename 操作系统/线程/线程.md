# 概念

+ LWP：light weight process 轻量级的进程，本质仍是进程（在linux环境下）。也有PCB，创建线程使用的底层函数和进程一样都是clone。是系统分配时间轮片的依据
+ 进程有独立的空间（0-4G的地址空间），拥有PCB。线程也有PBC，但是没有独立的地址空间（共享的）
+ 从内核上看进程和线程一样，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的
+ 进程可以蜕变成线程
+ 线程是最小的执行单位，进程是最小的分配资源单位
+ 线程可以看出是寄存器和栈的集合
+ 查看指定进程中的线程：ps -Lf pid(进程id)
+ 

# 共享资源和非共享资源

> **共享资源：**
>
> 1. 文件描述表
> 2. 每种**信号**的处理方式
> 3. 当前工作目录
> 4. 用户ID和组ID
> 5. 内存地址空间（.text/.data/.bss/heap/共享库）

> 非共享资源：
>
> 1. 线程id
> 2. 处理器现场和栈指针（内核栈）
> 3. 独立的栈空间（用户空间栈）
> 4. errno变量
> 5. 信号屏蔽字
> 6. 调度优先级
>
> **线程独享栈空间（内核栈和用户栈）

# 优缺点

> 优点：
>
> 1. 提高程序并发性
> 2. 开销小（多进程的话，要开辟多个地址空间）
> 3. 数据通信，共享数据方便

> 缺点：
>
> 1. 库函数，不稳定
> 2. 调试，编写困难，gdb不支持
> 3. 对信号支持不好

优先相对突出，缺点均不是硬伤。linux下由于实现方法导致进程，线程差别不是很大。

# 线程控制原语

> pthread_self：获取线程id
>
> 1. 获取线程ID
> 2. 线程ID是进程内部识别标志（两个进程间，线程ID允许相同）
> 3. 不应使用全局变量pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self

> pthread_create：创建线程
>
> 1. 在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()，返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。**start_routine函数返回时，这个线程就退出了**，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait()得到子进程的退出状态。
> 2. pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid()可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self()可以获得当前线程的id。

>  pthread_exit：退出该线程
>
> 1. exit：退出进程。pthread_exit：退出线程。return：返回到调用者
> 2. 调用线程退出函数，注意和exit函数的区别，任何线程里exit导致**进程**退出，其他线程未结束。而pthread_exit只退出当前自己的线程。
> 3. 线程中，禁止使用exit函数，会导致进程中所有线程全部退出。
> 4. pthread_exit和return返回的指针所指向的内存单元必须是**全局的或者是malloc分配的。**不能在线程函数的栈上分配，因为当其线程得到这个返回一指针时线程函数已经退出，内存被回收。

