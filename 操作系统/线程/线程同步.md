# 概念

> + 线程同步：一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其他线程为保证数据一致性，不能调用该功能。同一时刻操作共享资源只能有一个线程。其他线程需要等待该线程执行完。
>   + 例子：你在银行存了20000块。想从银行取钱可以用银行卡，或者用存折。那在同一天的同一时刻，你妈妈用你的存折去银行A取了1W，你用银行卡在银行B取了5K。那该时刻银行只允许有一方的操作可以进行（要么是你妈妈，要么是你）。只有等待一方操作完成后，银行才会继续另一方的操作。否则可能出现了剩余钱大于5K的情况。
> + 造成数据混乱的情况：
>   1. 共享数据
>   2. 多个对象竞争
>   3. 多个对象在竞争时没有合理的同步机制
> + 要使多个线程具有同步机制可以使用锁：在使用共享资源的前部加锁，使用完共享资源后解锁。
> + 我们编程使用到的锁都是建议锁，不具有强制性 。
>   + 例子：有线程A,B,C。三个线程都共享数据val。A线程执行循环10次，每次val=A并且打印val。B线程执行循环10次，每次val=B并且打印val。C线程执行循环10次，每次val=C并且打印val。线程A先加锁，然后去打印。线程B也加锁，但是这个时候线程A还没释放锁，这时会挂起等待线程A放锁。线程C不加锁，直接执行复制并且打印。那输出的结果可能就会混乱，打印A的同时打印C

> + 临界区：操作共享资源的区域（代码段）
> + 保护临界区：保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。
> + 临界区的选定因尽可能小，如果选定太大会影响程序的并行处理性能。

> + 造成死锁现象：
>   1. 线程视同对同一个互斥量A加锁两次
>   2. 线程1拥有A锁，请求加锁B。线程2拥有B锁，请求加锁A
> + 避免死锁：
>   1. 加锁用完后必须放锁。
>   2. 线程1拥有A锁，请求加锁B时应该是尝试加锁B（trylock）。如果trylock加锁失败的话，那就释放自己拥有的锁。牺牲自己，去成全其他线程。

# 互斥量（互斥锁）

+ 所选择的加锁区域应该尽可能的小
+ 同一时刻，只有一个线程会拥有这把锁
+ 线程A对共享数据加锁访问，线程B这时去加锁访问会阻塞，等待锁的释放。
+ 即使线程加了锁，但是有其他线程不按照规则（访问共享数据之前加锁）访问共享数据，依然会造成数据混乱
+ 优点：条件变量可以减少竞争，提高性能 

> 原理：
>
> 1. 调用初始化互斥量时，互斥量初始化为1
> 2. 加锁互斥量时，互斥量减1为0，进入临界区。其他线程要去加锁互斥量访问临界区时，发现值位0则等待**挂起**
> 3. 释放互斥量时，互斥量加1位1，退出临界区并唤醒其他线程。其他等待线程被唤醒后，去加锁互斥量访问临界区。

> pthread_mutex_t 类型，本质是一个结构体。可以简化理解成一个整数
>
> pthread_mutex_init：初始化互斥量，设置值为1。动态初始化，适用于局部变量
>
> pthread_mutex_destroy：销毁互斥量
>
> pthread_mutex_lock：加锁互斥量，值加1。其他线程加锁失败会阻塞
>
> pthread_mutex_trylock：尝试加锁互斥量，如果加锁失败则直接返回，不会阻塞
>
> pthread_mutex_unlock：释锁互斥量，值减1。唤醒所有阻塞的线程
>
> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER：静态初始化，适用于全局变量和static关键字修饰的
>
> **初始化和销毁，要一起用。初始化后，马上写销毁**

# 读写锁

+ 读写锁具有三种状态
  1. 读模式下加锁状态（读锁）：如果线程以读模式对其加锁，那其他线程以读模式加锁会成功，以写模式加锁会失败。
  2. 写模式下加锁状态（写锁）：如果线程以写模式对其加锁，那其他线程不管以读模式还是写模式都会加锁失败。
  3. 不加锁状态
+ 读写锁的特点：
  1. 读时共享，写时独占
  2. 写锁优先级高
+ 例子：
  1.  有线程1，2，3，4。线程1先加了读锁，线程2，3，4依次都想去加读锁。线程2，3，4都可以加锁成功
  2.  有线程1，2，3，4。线程1先加了读锁，线程2，4依次都想去加读锁，线程3想去加写锁。。线程2可以加锁成功，但是线程3，4会阻塞住，需要线程1放锁后线程3才会加锁成功，然后线程3放锁后线程4才加锁成功。因为线程1加读锁，线程2也是加读锁，所以线程2加锁成功。因为线程3加写锁，所以阻塞住了，也导致线程4不管加什么锁都会阻塞。
+ N个线程都加了读锁，那需要需要放锁N次
+ 使用场景：适合于对共享数据读操作远大于写操作

> pthread_rwlock_t 类型
>
> pthread_rwlock_init：初始读写锁
>
> pthread_rwlock_destroy：销毁互斥量
>
> pthread_rwlock_rdlock：加读锁，其他线程加锁失败会阻塞。
>
> pthread_rwlock_tryrdlock：尝试加读锁，如果加锁失败则直接返回，不会阻塞
>
> pthread_rwlock_wrlock：加写锁，其他线程加锁失败会阻塞。
>
> pthread_rwlock_trywrlock：尝试加写锁，如果加锁失败则直接返回，不会阻塞
>
> pthread_rwlock_t mutex = PTHREAD_WRLOCK_INITIALIZER：静态初始化，适用于全局变量和static关键字修饰的
>
> **初始化和销毁，要一起用。初始化后，马上写销毁**

# 条件变量

+ 条件变量本身不是锁！但是它也可以造成线程阻塞
+ 通用与互斥锁配合使用

> pthread_cond_wait：阻塞等待一个条件变量
>
> 原理：
>
> 1. 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&mutex);
> 2. 阻塞等待条件变量满足（cond）
> 3. 当条件变量满足时被唤醒，解锁阻塞
> 4. 重新申请获取互斥量pthread_mutex_lock(&mutex);
>
> **1，2两步为原子操作，3，4两步为原子操作**
>
> pthread_cond_timewait：有等待时间的阻塞

> 唤醒条件变量：
>
> 1. pthread_cond_signal：唤醒至少一个线程
> 2. pthread_cond_broadcast：唤醒所有线程

> pthread_cond_init：初始化条件变量。动态初始化，适用于局部变量
>
> pthread_cond_destroy：销毁互斥量
>
> pthread_cond_t mutex = PTHREAD_COND_INITIALIZER：静态初始化，适用于全局变量和static关键字修饰的
>
> **初始化和销毁，要一起用。初始化后，马上写销毁**

# 信号量

+ 互斥量的升级版。不仅可以用于线程间同步，还可以用于进程间同步

 sem

# 进程间同步

+ 信号量
+ 文件锁