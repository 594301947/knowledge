### 线程共享和非共享

> **共享资源：**
>
> 1. 文件描述表
> 2. 每种**信号**的处理方式
> 3. 当前工作目录
> 4. 用户ID和组ID
> 5. 内存地址空间（.text代码段/.data已初始化全局变量/.bss 未初始化全局变量/heap 堆/共享库）

> 非共享资源：
>
> 1. 线程id
> 2. 处理器现场和栈指针（内核栈）
> 3. 独立的栈空间（用户空间栈）
> 4. errno变量
> 5. 信号屏蔽字
> 6. 调度优先级
>
> **线程独享栈空间（内核栈和用户栈）**

### 线程使用的注意事项：

1. 主线程退出其他线程不退出，主线程应该调用pthread_exit
2. 避免僵尸线程
   1. pthread_join（被join线程可能在join函数返回之前就释放完自己的所有内存资源，所以不应该返回被回收线程栈中的值）
   2. pthread_detach
   3. pthread_create指定分离属性
3. malloc和mmap申请的内存空间可以被其他线程释放
4. **如果线程终止时没有释放加锁的互斥量，则该互斥量不能再被使用**
5. **应避免在多线程模型中调用fork。**子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit
6. 信号的复杂语义很难和多线程共享，应避免在多线程中引入信号机制

### 线程同步

| 同步机制 |                                                              |
| -------- | ------------------------------------------------------------ |
| 互斥锁   | 会造成CPU切换，不让后来的线程占用临界区。切换线程代价>等待代价 |
| 自旋锁   | 相当于while循环一直查询该临界区是否可用（忙等待）切换线程代<等待代价 |
| 原子操作 | 执行操作完全不可分，要么全部成功，要么全部失败               |
| 读写锁   | 临界区被加上写锁后，其他线程都加不上锁了。临界区被加上读锁后，其他线程还可以加上读锁，但是写锁家失败 |
| CAS      | 无锁机制。CAS(A,B,C) if A==B 则 A=C else return              |

### 条件变量

+ 要和互斥锁一起使用
+ 使用场景：取代才用while循环一直轮询等待条件到来，减少CPU的开销
+ 注意：使用条件变量要用while等待，不能使用if，防止虚假唤醒

### 面试题

> 京东：两个线程，共享一个整型变量 value，一个++ ，一个--，最后输出这个变量的值 value，如何最大
> 程度的提高并发能力？
>
> 答：无锁实现
>
> 1. 将value复制给两个变量v1和v2，初始值设置为value
> 2. 线程 1 对 v1++，线程 2 对 v2—
> 3. 最后执行完后，将 v1+v2

> 两个线程交替打印“ABCD”,"1234"
>
> 答：用条件变量控制
>
> 1. 线程A打印字母 -> wait -> notify 唤醒线程B
> 2. 线程B打印数字 -> wait -> notify 唤醒线程A

### 线程和进程的区别

|                        | 进程                  | 线程                                 |
| ---------------------- | --------------------- | ------------------------------------ |
| 概念                   | CPU资源最小的分配单位 | CPU最小的调度单位                    |
| 是否拥有独立的地址空间 | 有                    | 没有                                 |
| 切换速度               | 快                    | 慢                                   |
| 占用资源               | 多（4G）              | 少（每个线程默认占用1MB堆栈）        |
| 安全性                 | 相互独立，互不影响    | 一个线程崩溃，可能会导致整个进程崩溃 |
| 通信代价               | 大                    | 小                                   |

### errno的多线程问题

+ 每个系统调用失败后，都会设置errno。在多线程中，每个线程都有属于自己的errno，只保存自己线程的错误码，互不影响
