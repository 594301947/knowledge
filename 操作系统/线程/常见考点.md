### 线程共享和非共享

> **共享资源：**
>
> 1. 文件描述表
> 2. 每种**信号**的处理方式
> 3. 当前工作目录
> 4. 用户ID和组ID
> 5. 内存地址空间（.text代码段/.data已初始化全局变量/.bss 未初始化全局变量/heap 堆/共享库）

> 非共享资源：
>
> 1. 线程id
> 2. 处理器现场和栈指针（内核栈）
> 3. 独立的栈空间（用户空间栈）
> 4. errno变量
> 5. 信号屏蔽字
> 6. 调度优先级
>
> **线程独享栈空间（内核栈和用户栈）**

### 线程使用的注意事项：

1. 主线程退出其他线程不退出，主线程应该调用pthread_exit
2. 避免僵尸线程
   1. pthread_join（被join线程可能在join函数返回之前就释放完自己的所有内存资源，所以不应该返回被回收线程栈中的值）
   2. pthread_detach
   3. pthread_create指定分离属性
3. malloc和mmap申请的内存空间可以被其他线程释放
4. **如果线程终止时没有释放加锁的互斥量，则该互斥量不能再被使用**
5. **应避免在多线程模型中调用fork。**子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit
6. 信号的复杂语义很难和多线程共享，应避免在多线程中引入信号机制

### Linux的4种锁机制

+ 互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒

+ 读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。

+ 自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。
+ CAS：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用CAS时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。

### 线程同步

| 同步机制 |                                                              |
| -------- | ------------------------------------------------------------ |
| 互斥锁   | 会造成CPU切换，不让后来的线程占用临界区。切换线程代价>等待代价 |
| 自旋锁   | 相当于while循环一直查询该临界区是否可用（忙等待）切换线程代<等待代价 |
| 原子操作 | 执行操作完全不可分，要么全部成功，要么全部失败               |
| 读写锁   | 临界区被加上写锁后，其他线程都加不上锁了。临界区被加上读锁后，其他线程还可以加上读锁，但是写锁家失败 |
| CAS      | 无锁机制。CAS(A,B,C) if A==B 则 A=C else return              |
| 信号量   | 它只取自然数值，并且只支持两种操作：<br>P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。<br>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。 |

### 互斥锁（mutex）

+ 互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。

### 读写锁

+ 读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；**写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）**。适用于读取数据的频率远远大于写数据的频率的场合。

### 条件变量

+ 要和互斥锁一起使用
+ 使用场景：取代才用while循环一直轮询等待条件到来，减少CPU的开销
+ 注意：使用条件变量要用while等待，不能使用if，防止虚假唤醒

### 面试题

> 京东：两个线程，共享一个整型变量 value，一个++ ，一个--，最后输出这个变量的值 value，如何最大
> 程度的提高并发能力？
>
> 答：无锁实现
>
> 1. 将value复制给两个变量v1和v2，初始值设置为value
> 2. 线程 1 对 v1++，线程 2 对 v2—
> 3. 最后执行完后，将 v1+v2

> 两个线程交替打印“ABCD”,"1234"
>
> 答：用条件变量控制
>
> 1. 线程A打印字母 -> wait -> notify 唤醒线程B
> 2. 线程B打印数字 -> wait -> notify 唤醒线程A

### 线程和进程的区别

|                        | 进程                  | 线程                                 |
| ---------------------- | --------------------- | ------------------------------------ |
| 概念                   | CPU资源最小的分配单位 | CPU最小的调度单位                    |
| 是否拥有独立的地址空间 | 有                    | 没有                                 |
| 切换速度               | 快                    | 慢                                   |
| 占用资源               | 多（4G）              | 少（每个线程默认占用1MB堆栈）        |
| 安全性                 | 相互独立，互不影响    | 一个线程崩溃，可能会导致整个进程崩溃 |
| 通信代价               | 大                    | 小                                   |

### errno的多线程问题

+ 每个系统调用失败后，都会设置errno。在多线程中，每个线程都有属于自己的errno，只保存自己线程的错误码，互不影响
