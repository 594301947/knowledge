# 虚拟地址空间

+ linux每运行一个进程，操作系统都会分配一个0~4G的虚拟地址空间

+ 我们每运行一个进程，并非真的少了4G的物理内存。而是用了多少才减多少。

+ 每个进程的虚拟地址空间都互不影响

+ CPU为什么要使用虚拟地址空间与物理地址空间映射？解决了什么样的问题？

  + 方便编译器和操作系统安排程序的地址分布。程序可以使用一系列连续的虚拟地址空间来访问物理内存中不连续的内存缓冲区
  + 方便进程之间隔离。不同进程使用的虚拟地址彼此隔离。一个进程的代码无法更正正在由另一个进程使用的物理内存。
  + 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常是4K）保存到磁盘文件。数据或者代码页会根据需要在物理内存与磁盘之间移动。 

+ 虚拟地址空间由0~3G的用户空间，3G~4G的内核空间（kernel）组成。内核空间是受保护的。用户不能对该空间进行写操作，否则会出现段错误。

  > 0~3G的用户空间主要组成部分：
  >
  > 1. 栈空间：自顶向下分配地址
  > 2. 共享库
  > 3. 堆空间：自底向上分配地址
  > 4. .bss（未初始化全局变量）
  > 5. .data（已初始化全局变量）
  > 6. .text（代码段）

  > 3G~4G的内核空间组要组成部分：
  >
  > 1. 内存管理
  > 2. 进程管理
  > 3. 设备驱动管理
  > 4. VFS虚拟文件系统

  虚拟地址空间：

  ![虚拟地址空间](G:\knowledge\操作系统\进程\images\虚拟地址空间.png)

# 进程控制块（PCB）

+ 每个进程在内核中都有一个进程控制块（PCB）来维护进程相关信息。linux内核进程控制块是task_struct结构体
+ 进程控制块主要包括以下：
  + 进程id。系统中每个进程有一个唯一得分id，在C语言中用pid_t类型表示，其实是个非负整数
  + 进程的状态：初始化，就绪，运行，挂起，停止状态。
  + 进程切换时需要保存和回复的一些CPU寄存器信息。该进程时间片用完时需要保存寄存器的一些信息，等待下次CPU分配了时间片，以便继续执行
  + 描述虚拟地址空间信息。虚拟地址和物理地址的对应关系
  + 描述控制终端信息
  + 当前工作目录
  + umask掩码
  + 文件描述符表（简单理解文件描述符的数组）
  + 信号相关的信息
  + 用户id和组id
  + 会话和进程组
  + 进程可以使用的资源上限

# 进程的状态

+ 进程基本的状态有5中。分别是初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。
  + 就绪态：进程等待CPU分配时间片
  + 运行态：正在占用CPU
  + 停止：进程运行结束
  + 挂起：等待除CPU以外的其他资源（阻塞），主动放弃CPU

> 进程五种状态：![进程五种状态](G:\knowledge\操作系统\进程\images\进程的五种状态.png)

# 进程原语

> 头文件：#include <unistd.h>

> **创建一个子进程：fork**
>
> pid_t fork(void);
>
> 返回值：调用一次返回两次。父进程返回一次，子进程返回一次。
>
> + 父进程返回的是：子进程的id号。（-1为失败）
> + 子进程返回的是：0
>
> **特点：**
>
> + 子进程复制父进程的0到3g空间和父进程内核中的PCB，但id号不同
> +  读时共享，写时复制
> + 父进程和子进程都会继续从调用fork函数之后的代码开始执行。子进程不会从头开始执行。

