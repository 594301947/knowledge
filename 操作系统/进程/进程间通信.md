# 概念

+ 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。
+ 每个进程都有0-4G的地址空间，其中0-3G用户空间是自己独享的，其他进程没法访问。3G-4G的内核空间，虽然虚拟区域不同，但是所指向的物理区域是相同的。系统能通过内核空间进行进程间通信
+ 常用的进程间通信方式有：
  1. 管道（使用最简单）
  2. 信号（开销最小）
  3. 共享映射区（无血缘关系）
  4. 本地套接字（最稳定）
  5. FIFO（无血缘关系的管道）

> 进程间通信：![进程间通信](G:\knowledge\操作系统\进程\images\进程间通信.png)

# 管道

> #include <unistd.h>
> int pipe(int filedes[2]);
>
> 返回值：成功返回0，失败-1设置errno
>
> + 调用成功返回r/w两个文件描述符，**无需open，但是需要手动close。**
> + 需要一个进程关闭写端，一个进程关闭读端

+ 调用pipe函数时在内核中开辟一块内核缓冲区，是环形队列（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，**filedes[0]指向管道的读端，filedes[1]指向管道的写端**（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);
+ **向这个文件读写数据其实是在读写内核缓冲区**。pipe函数调用成功返回0，调用失败返回-1
+ 作用于有血缘关系的进程之间，通过fork来传递，完成数据传递
+ 特质：
  1. 其本质是一个伪文件（实际是内核缓冲器）
  2. 由两个文件描述符引用，一个表示读端，一个表示写端
  3. 规定数据从管道的写端流入管道，从读端流出。半双工通信，一次只能从一个方向通信
+ 局限性：
  1. 数据自己读不能写
  2. 数据一旦被读走，便不再管道中存在，不可反复读取
  3. 由于管道是半双工通信方式，因此数据只能在一个方向流动，只能实现单向通信。
  4. 只能在有公共祖先的进程间使用管道
+ **注意4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：**
  1. 如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样
  2. 如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，**再次read会阻塞**，直到管道中有数据可读了才读取数据并返回。
  3. 如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止（默认）。
  4. 如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，**那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。**

> 管道步骤：![管道步骤](G:\knowledge\操作系统\进程\images\管道步骤.png)